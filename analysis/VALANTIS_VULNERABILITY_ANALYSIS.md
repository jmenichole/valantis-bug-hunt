# Valantis Core - Source Code Analysis from GitHub

**Date**: December 11, 2025  
**Source**: github.com/ValantisLabs/valantis-core  
**Analysis Focus**: Pattern 1 (Proxy Initialization) & Pattern 6 (Access Control)

---

## KEY FINDINGS

### 1. SovereignPool.setALM() - POTENTIAL VULNERABILITY ‚ö†Ô∏è

**Location**: `src/pools/SovereignPool.sol:535-568`

```solidity
function setALM(address _alm) external override onlyPoolManager nonReentrant {
    if (_alm == address(0)) {
        revert SovereignPool__ZeroAddress();
    }

    if (alm != address(0)) {
        revert SovereignPool__ALMAlreadySet();
    }

    alm = _alm;

    emit ALMSet(_alm);
}
```

**Analysis**:
- ‚úÖ Has `onlyPoolManager` modifier (access control)
- ‚úÖ Has `nonReentrant` protection
- ‚úÖ Can only be set once (`alm != address(0)` check)
- ‚úÖ **SECURE** - No initialization bypass vulnerability

---

### 2. ProtocolFactory.deploySovereignPool() - ANALYSIS

**Location**: `src/protocol-factory/ProtocolFactory.sol:724-748`

```solidity
function deploySovereignPool(SovereignPoolConstructorArgs memory args) external override returns (address pool) {
    if (!Address.isContract(args.token0) || !Address.isContract(args.token1)) {
        revert ProtocolFactory__tokenNotContract();
    }

    args.protocolFactory = address(this);

    pool = IPoolDeployer(sovereignPoolFactory).deploy(bytes32(0), abi.encode(args));

    _sovereignPools[args.token0][args.token1].add(pool);

    emit SovereignPoolDeployed(args.token0, args.token1, pool);
}
```

**Analysis**:
- ‚ùå **NO ACCESS CONTROL** - Anyone can deploy a pool!
- ‚úÖ Validates tokens are contracts
- ‚ö†Ô∏è **POTENTIAL ISSUE**: No permission check on who can deploy pools
- ‚ö†Ô∏è Pools can be created by anyone with any parameters

**Attack Vector**:
Attacker could deploy malicious pools through the factory, potentially:
1. Creating fake pools with malicious ALM addresses
2. Deploying pools with malicious verifier modules
3. Impersonating legitimate token pairs

---

### 3. Access Control on Factory Functions

**Protocol Manager Functions** (Protected):
```solidity
modifier onlyProtocolManager() {
    if (msg.sender != protocolManager) {
        revert ProtocolFactory__onlyProtocolManager();
    }
    _;
}
```

Protected functions:
- `addUniversalALMFactory()` ‚úÖ
- `addSovereignALMFactory()` ‚úÖ
- `removeUniversalALMFactory()` ‚úÖ
- `removeSovereignALMFactory()` ‚úÖ

**Protocol Deployer Functions** (Protected):
```solidity
modifier onlyProtocolDeployer() {
    if (msg.sender != protocolDeployer) {
        revert ProtocolFactory__onlyProtocolDeployer();
    }
    _;
}
```

Protected functions:
- `setUniversalPoolFactory()` ‚úÖ
- `setSovereignPoolFactory()` ‚úÖ
- `setProtocolManager()` ‚úÖ

---

### 4. Sovereign Pool Constructor - NO INITIALIZE PATTERN

**Location**: `src/pools/factories/SovereignPoolFactory.sol:23-28`

```solidity
function deploy(bytes32, bytes calldata _constructorArgs) external override returns (address deployment) {
    SovereignPoolConstructorArgs memory args = abi.decode(_constructorArgs, (SovereignPoolConstructorArgs));

    // Salt to trigger a create2 deployment
    bytes32 salt = keccak256(abi.encode(nonce, block.chainid, _constructorArgs));
    
    nonce++;
    
    deployment = address(new SovereignPool{ salt: salt }(args));
}
```

**Analysis**:
- ‚úÖ Uses constructor pattern, NOT initialize()
- ‚úÖ No proxy pattern detected
- ‚úÖ Uses CREATE2 for deployment
- ‚úÖ **SECURE** from Pattern 1 (no initialize bypass possible)

---

### 5. Pool Manager Controls

**Sovereign Pool Access Control**:
```solidity
modifier onlyPoolManager() {
    if (msg.sender != poolManager) {
        revert SovereignPool__onlyPoolManager();
    }
    _;
}
```

Functions protected by `onlyPoolManager`:
- `setALM()` ‚úÖ
- `setSwapFeeModule()` ‚úÖ (with 3-day timelock)
- `setPoolManager()` ‚úÖ
- `setPoolManagerFeeBips()` ‚úÖ

---

## VULNERABILITY SUMMARY

### üö® CRITICAL FINDING: Permissionless Pool Deployment

**Pattern**: Pattern 6 - Access Control Bypass  
**Severity**: MEDIUM-HIGH  
**Impact**: Anyone can deploy pools through ProtocolFactory

**Details**:
The `deploySovereignPool()` function has NO access control. Any address can:
1. Deploy a pool with arbitrary parameters
2. Set themselves as `poolManager`
3. Set malicious `verifierModule`
4. Control the pool's ALM, swap fees, and oracle

**Proof of Concept**:
```solidity
// Attacker deploys fake USDC/ETH pool
SovereignPoolConstructorArgs memory args;
args.token0 = USDC_ADDRESS;
args.token1 = ETH_ADDRESS;
args.poolManager = attacker; // Attacker controls pool
args.verifierModule = maliciousVerifier; // Bypass access checks
args.sovereignVault = attackerVault; // Steal funds

address fakePool = protocolFactory.deploySovereignPool(args);
// Now attacker controls a pool that LOOKS legitimate
```

**Exploitation**:
1. Deploy fake pool for popular token pair
2. Trick users into depositing via phishing
3. Set malicious ALM to drain funds
4. Front-run legitimate integrations

**Recommendation**:
Add access control to `deploySovereignPool()`:
```solidity
function deploySovereignPool(SovereignPoolConstructorArgs memory args) 
    external 
    onlyProtocolManager  // ADD THIS
    override 
    returns (address pool) 
{
    // existing code...
}
```

---

### ‚úÖ SECURE PATTERNS FOUND

1. **No Proxy Initialization Vulnerability** - Uses constructors, not initialize()
2. **Reentrancy Protection** - Uses ReentrancyGuard on critical functions
3. **ALM Can Only Be Set Once** - Prevents re-initialization of ALM
4. **Timelock on Swap Fee Module** - 3-day delay prevents immediate changes
5. **Pool Manager Access Control** - Most pool functions properly protected

---

## RECOMMENDED NEXT STEPS

1. **Verify on Etherscan** if deployed contracts match GitHub source
2. **Check if pools are whitelisted** in frontend/documentation
3. **Look for official pool registry** to differentiate real vs fake pools
4. **Test permissionless deployment** on mainnet (read-only simulation)
5. **Document findings** for bug bounty submission

---

## ADDITIONAL ATTACK VECTORS TO INVESTIGATE

### Pattern 2: Flash Loan Reentrancy
- ‚úÖ ReentrancyGuard present
- Need to test flash loan callback patterns

### Pattern 3: Oracle Manipulation
- Oracle module is optional
- Need to check if sovereign oracle can be manipulated

### Pattern 4: Flash Swap Slippage
- Need to analyze ALM liquidity quote mechanism
- Check if slippage can be bypassed

### Pattern 7: Signature Validation
- No signature-based functions found yet
- May exist in ALM or Verifier modules

---

**STATUS**: Potential vulnerability identified in permissionless pool deployment.  
**NEXT**: Create POC test to demonstrate attack vector.
